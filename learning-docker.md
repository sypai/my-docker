## Getting Started with Containers

**Run a container**

`docker container run --publish --detach 8080:80 --name webhost nginx`

`run` Start a new container from image `nginx` (download from docker hub if not found locally)

`--publish` or `-p` Binds container's TCP port 8080 to host's port 80

`--detach` or `-d` Runs the container in background

**Stop a container**

`docker container stop <docker_id / docker_name>`

**List running containers**

`docker container ls`

Add `-a` or `-all` to include stopped containers

`docker ps`

`docker ps` is shorthand that stands for "docker process status", whilst `docker container ls` is shorthand for the more verbose docker container list. There is no difference in how they work, and `docker container ls` is the 'newer' command, so you should probably prefer it.

**Delete all running and stopped containers**

`docker container rm -f <docker ids / docker names>`

**Print container's logs**

`docker container logs --tail 100 <docker id / docker name>`

`--tail` print last 100 lines of log

**List processes running inside a container**

`docker top <container name>`

Display the running processes of a container

**Create, start & run**

`docker create` adds a writeable container on top of your image and sets it up for running whatever command you specified in your CMD. The container ID is reported back but it’s not started.

`docker start` will start any stopped containers. This includes freshly created containers.

`docker run` is a combination of create and start. It creates the container and starts it.

**Process Monitoring**

`docker top [container]` Display the running processes of a container

`docker inspect [container]` Display detailed information on one or more containers

`docker stats [container]` Display a live stream of container(s) resource usage statistics

**Getting a shell inside containers**

`docker container exec [OPTIONS] <container-name>` Run a command in a running container

`-t` or `--tty` Allocates a pseudo-TTY and simulates a real terminal like what SSH does

`-i` or `--interactive` Keep STDIN open even if not attached (Keep session open to receive terminal input)

## Docker Networks

`docker network ls` List Networks

`docker network create` Create a network. The `DRIVER` accepts `bridge` or `overlay` which are the built-in network drivers. If you have installed a third party or your own custom network driver you can specify that `DRIVER` here also. If you don’t specify the `--driver` option, the command automatically creates a `bridge` network for you. When you install Docker Engine it creates a `bridge` network automatically. This network corresponds to the `docker0` `bridge` that Engine has traditionally relied on. When you launch a new container with `docker run` it automatically connects to this `bridge` network. You cannot remove this default `bridge` network, but you can create new ones using the network create command. 

`$ docker network create -d bridge my-bridge-network
`

`docker network inspect` Display detailed information on one or more networks. Returns information about one or more networks. By default, this command renders all results in a JSON object.

`docker network connect` Connect a container to a network

`docker network disconnect` Disconnect a container from a network

`docker network prune` Remove all unused networks. Unused networks are those which are not referenced by any containers.

`docker network rm` Remove one or more networks by name or identifier. To remove a network, you must disconnect any containers connected to it.

## Docker Images

`docker image build` Build an image from a Dockerfile

`docker image history` Show the history of an image

`docker image inspect` Display detailed information on one or more images

`docker image ls` List images

`docker image prune` Remove all dangling images. If `-a` is specified, will also remove all images not referenced by any container

`docker image pull NAME` Pull an image or a repository from a registry

`docker image push NAME` Push an image or a repository to a registry

`docker image rm` Remove one or more images

`docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]` Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE

## Docker Volumes

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. Docker volumes are file systems mounted on Docker containers to preserve data generated by the running container.

The volumes are stored on the host, independent of the container life cycle. This allows users to back up data and share file systems between containers easily. 

`docker volume create [OPTIONS] [VOLUME]` Creates a new volume that containers can consume and store data in. If a name is not specified, Docker generates a random name.

`docker volume inspect [OPTIONS] VOLUME [VOLUME...]` Returns information about a volume. By default, this command renders all results in a JSON array. You can specify an alternate format to execute a given template for each result.

`docker volume ls [OPTIONS]` List all the volumes known to Docker. You can filter using the `-f` or `--filter` flag.

`docker volume prune [OPTIONS]` Remove all unused local volumes. Unused local volumes are those which are not referenced by any containers

`docker volume rm [OPTIONS] VOLUME [VOLUME...]` Remove one or more volumes. You cannot remove a volume that is in use by a container.

### Persistent Data using Bind Mounts
When you use a bind mount, a file or directory on the host machine is mounted into a container. The file or directory is referenced by its absolute path on the host machine. By contrast, when you use a volume, a new directory is created within Docker’s storage directory on the host machine, and Docker manages that directory’s contents.

The file or directory does not need to exist on the Docker host already. It is created on demand if it does not yet exist. Bind mounts are very performant, but they rely on the host machine’s filesystem having a specific directory structure available. If you are developing new Docker applications, consider using named volumes instead. You can’t use Docker CLI commands to directly manage bind mounts.

### Using `-v` or `--mount` flag

In general, --mount is more explicit and verbose. The biggest difference is that the -v syntax combines all the options together in one field, while the --mount syntax separates them.

`-v` or `--volume`  Consists of three fields, separated by colon characters `(:)`. The fields must be in the correct order.
-   In the case of bind mounts, the first field is the path to the file or directory on the host machine.
-   The second field is the path where the file or directory is mounted in the container.
-   The third field is optional, and is a comma-separated list of options, such as `ro`, `z`, and `Z`. These options are discussed below.

`--mount`  Consists of multiple key-value pairs, separated by commas and each consisting of a `<key>=<value>` tuple. The --mount syntax is more verbose than -v or --volume, but the order of the keys is not significant, and the value of the flag is easier to understand.
-   The `type` of the mount, which can be bind, volume, or tmpfs. This topic discusses bind mounts, so the type is always bind.
-   The `source` of the mount. For bind mounts, this is the path to the file or directory on the Docker daemon host. May be specified as source or src.
-   The `destination` takes as its value the path where the file or directory is mounted in the container. May be specified as destination, dst, or target.
-   The `readonly` option, if present, causes the bind mount to be mounted into the container as read-only.
-   The `bind-propagation` option, if present, changes the bind propagation. May be one of rprivate, private, rshared, shared, rslave, slave.
-   The --mount flag does not support `z` or `Z` options for modifying selinux labels.


```python
# Using --mount
docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source="$(pwd)"/target,target=/app \
  nginx:latest


# Using -v
docker run -d \
  -it \
  --name devtest \
  -v "$(pwd)"/target:/app \
  nginx:latest
```